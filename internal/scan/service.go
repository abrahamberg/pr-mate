package scan

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"

	prcontext "prmate/internal/context"
	"prmate/internal/github"
	"prmate/internal/scanner"
)

// Service orchestrates codebase scanning and .prmate.md generation
type Service struct {
	githubClient *github.Client
	generator    *prcontext.Generator
}

// NewService creates a new scan service
func NewService(githubClient *github.Client) *Service {
	return &Service{
		githubClient: githubClient,
		generator:    prcontext.NewGenerator(),
	}
}

// ScanRequest contains parameters for a scan operation
type ScanRequest struct {
	Owner         string
	Repo          string
	PRNumber      int
	Branch        string
	ExternalRepos []string // repos from @scan directive
}

// ScanResult contains the results of a scan operation
type ScanResult struct {
	PRMateContent string
	TempFilePath  string
	Error         error
}

// ProcessScan runs the full scan flow: clone, scan, generate .prmate.md, commit and push
func (s *Service) ProcessScan(ctx context.Context, req ScanRequest) (*ScanResult, error) {
	result := &ScanResult{}

	// Create temp directory for cloning
	workDir, err := os.MkdirTemp("", "prmate-scan-*")
	if err != nil {
		return nil, fmt.Errorf("create work dir: %w", err)
	}
	defer os.RemoveAll(workDir)

	// Clone current repo
	repoPath := filepath.Join(workDir, req.Repo)
	if err := s.cloneRepo(ctx, req.Owner, req.Repo, req.Branch, repoPath); err != nil {
		return nil, fmt.Errorf("clone repo: %w", err)
	}

	log.Printf("Cloned %s/%s to %s", req.Owner, req.Repo, repoPath)

	// Create multi-repo scanner
	multiScanner, err := scanner.NewMultiRepoScanner(s.githubClient.GetToken())
	if err != nil {
		return nil, fmt.Errorf("create multi-repo scanner: %w", err)
	}
	defer multiScanner.Cleanup()

	// Scan current repo and externals
	scanResult, err := multiScanner.ScanWithExternals(ctx, repoPath, req.ExternalRepos)
	if err != nil {
		return nil, fmt.Errorf("scan repos: %w", err)
	}

	log.Printf("Scanned %s with %d external repos", req.Repo, len(req.ExternalRepos))

	// Generate .prmate.md content
	content := s.generator.Generate(scanResult)
	result.PRMateContent = content

	// Write to temp file for reference
	tempPath, err := s.generator.WriteToTemp(content)
	if err != nil {
		return nil, fmt.Errorf("write temp file: %w", err)
	}
	result.TempFilePath = tempPath

	// Write .prmate.md to cloned repo and commit+push using git
	prmatePath := filepath.Join(repoPath, ".prmate.md")
	if err := os.WriteFile(prmatePath, []byte(content), 0644); err != nil {
		return nil, fmt.Errorf("write .prmate.md: %w", err)
	}

	// Commit and push using git
	if err := s.commitAndPush(ctx, repoPath, req.Branch); err != nil {
		return nil, fmt.Errorf("commit and push: %w", err)
	}

	log.Printf("Updated .prmate.md in %s/%s branch %s via git push", req.Owner, req.Repo, req.Branch)

	return result, nil
}

// cloneRepo clones a specific branch of a repo
func (s *Service) cloneRepo(ctx context.Context, owner, repo, branch, destPath string) error {
	cloneURL := s.githubClient.CloneURL(owner, repo)

	args := []string{"clone", "--depth=1", "--branch", branch, cloneURL, destPath}
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")

	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("git clone: %s: %w", string(output), err)
	}

	return nil
}

// commitAndPush stages .prmate.md, commits, and pushes to the branch
func (s *Service) commitAndPush(ctx context.Context, repoPath, branch string) error {
	// Configure git user for the commit
	if err := s.runGit(ctx, repoPath, "config", "user.email", "prmate@github.com"); err != nil {
		return fmt.Errorf("git config email: %w", err)
	}
	if err := s.runGit(ctx, repoPath, "config", "user.name", "PRMate Bot"); err != nil {
		return fmt.Errorf("git config name: %w", err)
	}

	// Stage .prmate.md
	if err := s.runGit(ctx, repoPath, "add", ".prmate.md"); err != nil {
		return fmt.Errorf("git add: %w", err)
	}

	// Check if there are changes to commit
	cmd := exec.CommandContext(ctx, "git", "diff", "--cached", "--quiet")
	cmd.Dir = repoPath
	if err := cmd.Run(); err == nil {
		// No changes to commit
		log.Printf("No changes to .prmate.md, skipping commit")
		return nil
	}

	// Commit
	if err := s.runGit(ctx, repoPath, "commit", "-m", "Update .prmate.md context (auto-generated by PRMate)"); err != nil {
		return fmt.Errorf("git commit: %w", err)
	}

	// Push
	if err := s.runGit(ctx, repoPath, "push", "origin", branch); err != nil {
		return fmt.Errorf("git push: %w", err)
	}

	return nil
}

// runGit executes a git command in the given directory
func (s *Service) runGit(ctx context.Context, repoPath string, args ...string) error {
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = repoPath
	cmd.Env = append(os.Environ(), "GIT_TERMINAL_PROMPT=0")

	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(output), err)
	}
	return nil
}

// CheckForScanDirective checks if .prmate.md contains @scan directive
func (s *Service) CheckForScanDirective(ctx context.Context, owner, repo, branch string) (bool, []string, error) {
	content, err := s.githubClient.GetFileContent(ctx, owner, repo, ".prmate.md", branch)
	if err != nil {
		// File doesn't exist, no directive
		return false, nil, nil
	}

	reader := scanner.NewInstructionsReader()

	if !reader.HasScanDirective(content) {
		return false, nil, nil
	}

	repos := reader.ParseScanDirective(content)
	return true, repos, nil
}

// CheckForPRMateDirective checks if content contains @prmate directive
func (s *Service) CheckForPRMateDirective(content string) bool {
	reader := scanner.NewInstructionsReader()
	return reader.HasPRMateDirective(content)
}

// RemoveScanDirectiveFromContent removes @scan from content
func (s *Service) RemoveScanDirectiveFromContent(content string) string {
	reader := scanner.NewInstructionsReader()
	return reader.RemoveScanDirective(content)
}
